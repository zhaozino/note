
Multi-Runtime Microservices Architecture

分布式应用程序的4类需求
	1、生命周期：Packaging、Healthcheck、Deployment、Scaling、Configuration
	2、网络：Service discovery、A/B testing,canary rollouts/蓝绿、Retry、timeout,ciruit breaker、Point-to-point、pub/sub、Security,observability/遥测
	3、状态：服务编排、Workflow mgmt、Idempotency/幂等、Temporal scheduling/时间调度、Caching、Application state
	4、绑定：Connectors、Protocol conversion、Message transformation、Message routing、Transactionality/事务

未来的架构趋势是通过将所有传统的中间件功能移至其他运行时来全面发展，最后的目标是在服务中只需编写业务逻辑。

1、生命周期（Lifecycle）
	让我们从基础开始。当我们编写一项功能时，编程语言会提供此生态系统中的可用程序库、打包格式和运行时。例如，Java使用.jar格式以及所有Maven依赖作为生态系统，并将JVM作为运行时。如今，随着发布周期的缩短，生命周期中更重要的是能够自动化进行部署、错误恢复以及服务扩展的能力。这组能力广泛的代表了我们的应用生命周期需求。
2、网络（Networking）
	从某种意义上讲，今天几乎每个应用程序都是分布式应用，都需要网络。但是现代分布式系统需要从更广的视角去管理网络。从服务发现和错误恢复，到启用现代软件发布技术以及各种跟踪和遥测。为了这些目的，我们将不同的消息交换模式（点对点、发布/订阅方法以及智能路由机制）也包括在此类。
3、状态（State）
	当我们谈论状态时，通常是讲服务状态以及服务为什么最好是无状态的。但是管理我们服务的平台本身就需要状态。这对于执行可靠的服务编排和工作流、分布式单例、临时调度（cron作业）、幂等性、有状态的错误恢复、缓存等是必需的。此处列出的所有功能都依赖于底层的状态。虽然实际的状态管理不在本文讨论范围之内，但依赖状态的分布式原语及其抽象却是本文中要关注的。
4、绑定（Binding）
	分布式系统的组件不仅必须彼此通讯，而且还必须与现今或遗留的外部系统集成。这就要求连接器能够转换各种协议，支持不同的消息交换模式，例如轮询、事件驱动、请求/答复、转换消息格式，甚至能够执行自定义的错误恢复过程和安全机制。
	上述功能不特指具体使用案例，它表述的是一个通用原语的良好集合，这些原语正是创建优秀的分布式系统所需的。如今，许多平台都提供了这样的功能，但是本文中我们要探讨的是过去十年中我们使用这些功能的方式如何变化，以及在下一个十年中它又将如何变化。为了进行比较，让我们看一下过去的十年，基于Java的中间件如何满足这些需求。

传统中间件的限制
1、生命周期（Lifecycle）
	在传统的中间件中，通常只有一个受支持的语言运行时（例如Java），它规定了软件的打包方式、可用的库、必须维护的频率等。业务服务必须使用这些库，使其与平台（平台编写语言与业务服务是一样的）紧密结合。在生产实践中，这导致服务和平台的升级必须要协调，常规服务与平台的发布不能够独立进行。
2、网络（Networking）
	尽管传统中间件具有与内部和外部服务交互的高级功能，但它有一些主要缺点，网络功能集中于一种主要语言及其相关技术，对于Java语言，即JMS，JDBC，JTA等。更重要的是，网络问题和语义也深深地刻在业务服务中。有一些抽象能力的库来解决网络问题（例如曾经很受欢迎的Hystrix项目），但是该库的抽象“泄漏”到了服务的编程模型、交换模式、错误处理语义以及库本身中。虽然在一个位置可以方便的编写和读取整个业务逻辑（与网络问题混在一起），但是这导致两个问题紧密地耦合到同一实现中，最终形成了一个关联的演进路径。
3、状态（State）
	为了进行可靠的服务编排、业务流程管理以及实施模式（例如Saga模式和其它长时间运行的流程），平台需要在幕后持久化状态。同样，临时动作（例如触发计时器和cron作业）建立在状态之上，并且需要在分布式环境中对数据库进行集群化和弹性。这里的主要约束在于：与状态交互的库和接口没有完全抽象出来，也没有与服务运行时分离。通常，这些库必须配置有数据库详细信息，并且它们存在于服务中，从而将语义和依赖关系泄漏到应用程序域中。
4、绑定（Binding）
	使用集成中间件的一个主要原因是能够使用不同的协议、数据格式和消息交换模式连接到其它各种系统。但是，这些连接器必须与应用程序一起使用，这意味着必须将这些依赖与业务逻辑一起进行更新和维护；意味着必须在服务内来回转换数据类型和数据格式；意味着必须根据消息交换模式来构造代码并设计流程。这些示例展示了抽象端点如何影响传统中间件中服务实现。

云原生趋势
1、生命周期（Lifecycle）
	容器和Kubernetes将打包、发布和部署应用程序的方式发展为一种与语言无关的格式。关于Kubernetes模式和Kubernetes对开发人员的影响的文章很多，在这里我简短介绍。但是请注意，对于Kubernetes，管理的最小原语是容器，它专注于在容器级别和流程模型上提供分布式原语。这意味着它在管理应用程序的生命周期方面：运行状况检查、恢复、部署和扩展方面做得很出色，但是在容器内分布式应用的其它方面却没有做得很好，例如灵活的网络、状态管理和绑定。
	您可能会指出，Kubernetes具有状态型工作负载、服务发现、cron作业和其它功能。的确如此，但是所有这些原语都是在容器级别的。在容器内部，开发人员仍然必须使用特定语言的库来访问我们在本文开头列出的更细粒度的功能。这也是促使诸如Envoy，Linkerd，Consul，Knative，Dapr，Camel-K等项目产生的原因。
2、网络（Networking）
	Kubernetes提供了围绕服务发现的基本网络功能，事实证明，这是一个很好的基础，但对于现代应用程序来说还不够。随着微服务数量的增加和部署速度的加快，对更高级的发布策略、管理安全性、运行指标、跟踪、故障恢复、错误模拟等方面的需求变得越来越强烈，并产生了一类新的软件，称为服务网格（ service mesh）。
	这里更令人兴奋的是，趋势是将与网络相关的关注点从包含业务逻辑的服务移到单独的运行时（无论是边车还是节点级代理），再移到单独的运行时。如今，服务网格可以执行高级路由、帮助测试、处理安全性的某些方面，甚至支持特定应用程序的协议（例如，Envoy支持Kafka，MongoDB，Redis，MySQL等）。尽管作为解决方案的服务网格可能尚未得到广泛采用，但它触及了分布式系统中的真正痛点，我相信它会成型而且找到最合适的存在形态。
3、状态（State）
	我们在前面列出了依赖状态的主要集成原语。管理状态非常困难，应将其委托给专门的存储软件和托管服务。这不是本文关注话题，但是通过语言无关的抽象及使用状态来帮助集成用例却是我们要讨论的。今天，有许多努力试图在语言无关的抽象后面提供有状态的原语。有状态的工作流管理是云服务中的必备的功能，例如AWS Step Functions，Azure Durable Functions等。在基于容器的部署中，CloudState和Dapr都依赖于sidecar模型提供对分布式应用中的状态抽象更好的解耦。
	我也期待可以将上面列出的所有有状态功能抽象到一个单独的运行时中。这意味着工作流管理、单例、幂等、事务管理、cron作业触发器和有状态错误处理都可靠的运行在边车（或主机级代理）中，而不是存在于服务中。业务逻辑不需要在应用程序中包含此类依赖和语义，它可以从绑定环境中声明性地请求此类行为。例如，Sidecar可以作为一个cron作业触发器、幂等消费者和工作流管理器，而自定义业务逻辑可以作为回调被执行或插入工作流的某些阶段、错误处理、临时调用或唯一幂等要求等。
	另一个有状态用例是缓存。无论是通过服务网格层执行请求缓存，还是使用Infinispan，Redis，Hazelcast等之类的数据缓存，都有一些将缓存功能转移到应用程序运行时之外的示例。
4、绑定（Binding）
	尽管我们讨论的主题是解耦所有分布式需求与应用程序运行时，但这种趋势也依然伴随着绑定。连接器、协议转换、消息转换、错误处理和安全认证都可以移出服务运行时。我们还没有达到那个程度，但是在诸如Knative和Dapr之类的项目已朝这个方向进行了尝试。将所有这些职责移出应用程序运行时将使得应用代码更精简、更注重业务逻辑。应用代码将在独立于分布式系统需求的运行时（指的是与业务逻辑无关的分布式功能），而分布式系统需求可以作为预安装功能使用。
	Apache Camel-K项目采用了另一种有趣的方法。该项目不是使用代理运行时来支持主应用程序，而是依靠智能的Kubernetes Operator来构建应用程序运行时，运行时同时具有Kubernetes和Knative等附加平台功能。在这里，唯一的代理是负责包括应用程序所需的分布式系统原语的operator。不同之处在于，某些分布式原语已添加到应用程序运行时中，另外一些已在平台中提供（也可能包括一个边车Sidecar）。
