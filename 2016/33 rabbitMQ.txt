
***********************************************************************

rabbitMQ/kafka

Erlang语言编写；

消息组件优点：异步、解耦、过载处理、横向扩展/负载均衡、消息队列；
	
	应用程序和Rabbit代理服务器之间创建一条TCP连接，一条TCP中有多个虚拟信道，通过唯一ID区别；
	
	AMQP消息路由必须有三部分：交换器、队列、绑定；
	生产者把消息发布到交换器上；消息最终到达队列，并被消费者接收；绑定决定了消息如何从路由器路由到特定队列；
	
	生产者 > 交换器(路由键) > 消息队列 > 消费者
	
	RabbitMQ服务器：交换器/消息队列；
	
	如果消息到达了无人订阅的队列，消息会在队列中等待，直到有消费者订阅到该队列；
	
	消费者接收到的每一条消息都必须进行确认，通过basic.ack显式确认，或者auto_ack自动确认；
	
	消费者对消息的确认和告诉生产者消息已经被接收了这两件事毫不相干；
	消费者通过确认命令告诉RabbitMQ它已经正确地接收了消息，同时RabbitMQ才能安全地把消息从队列中删除；

	//消息重发
	如果消费者收到一条消息，然后确认之前从RabbitMQ断开连接（或者从队列上取消订阅），RabbitMQ会认为这条消息没分发，
		然后重新分发给下一个订阅的消费者；如果你的程序崩溃了，这样做可以确保消息会被发送给另一个消费者进行处理，
		另一方面，如果应用程序有bug而忘记确认消息的话，在有多个消费者的情况下，Rabbit将不会给该消费者发送更多消息了，
		因为上一条消息被确认之前，Rabbit会认为这个消费者并没有准备好接收下一条消息，如果只有一个消费者，照样会发送消息；
		如果处理消息内容非常耗时，直到消息处理完才确认，这样可以防止Rabbit持续不断的消息涌向你的应用而导致过载；
		
	处理消息时遇到了不可恢复的错误，不能确认该消息：
		1、把消费者从RabbitMQ服务器断开，RabbitMQ自动重新把消息入队并发送给另一个消费者；
		2、reject，true：Rabbit会把消息转发给下一个订阅者；false：从队列移除，不发送给新的消费者；
		
	如果消费者在同一条信道上订阅了另一个队列的话，就无法再声明队列了；
	
	如果尝试声明一个已经存在的队列，Rabbit就什么都不做，并成功返回，就像成功创建了队列一样；

	发送出去的消息，如果路由到了不存在的队列，Rabbit会忽略它们；
	
	如果消息不匹配任何队列的话，消息会进入黑洞；

	交换器：direct、fanout、topic；
	
	direct：点对点模式，一个队列，可以对应多个消费者，一个消息只能被一个消费者消费；
		可以不声明交换器，使用空白字符串名称的默认交换器；
		也可以通过路由键绑定多个队列，不同路由键对应不同的队列；
		一个队列可以绑定多个路由键，多个队列也可以绑定一个相同的路由键；

	fanout：发布订阅模式，对应多个队列，每条消息都会发送到所有队列上；
	
	topic：正则表达式的发布订阅模式，它使得来自不同源头的消息能够到达同一队列；
		一条消息可以投递到多个队列，多条消息也可以投递到一个队列；
		
	vhost之间是绝对隔离的；
	
	如果消息想要从RabbitMQ服务器崩溃中恢复，必须满足下边3个条件：
		1、消息的投递模式设置为持久(delivery mode = 2)，持久化消息会影响性能；
		2、发送到持久化的交换器(durable = true)，宕机后，交换器会重建，否则消失；
		3、发送到持久化的队列(durable = true)，宕机后，交换器会重建，否则消失；
	
	//消息丢失
	持久化消息在RabbitMQ内建集群环境下工作的并不好，队列在集群中没有冗余备份，如果节点宕机，在节点恢复前，
		这个节点上队列也就从整个集群中消失了，持久化队列也无法重建，导致消息丢失；
		
	AMQP事务
		发布消息时RabbitMQ不会返回任何消息给生产者；
		把信道设置成事务模式，如果第一条命令失败后(RabbitMQ收到了消息，且路由到了相应队列)，后边的命令不会继续执行；
		缺点：性能太差；
		
	发送方确认模式
		把信道设置成confirm模式，而且你只能重新创建信道来关闭该设置；
		一旦信道进入confirm模式，所有在信道上发布的消息都会被指派一个唯一的ID(从1开始，每次加1)。
			一旦消息被投递给所有匹配的队列后，信道会发送一个发送方确认模式给生产者应用程序，
			包括消息的唯一ID，这使得生产者知晓消息已经安全到达目的队列了。如果消息和队列是持久化的，
			那么确认消息只会在队列将消息写入磁盘后才会发出。
		发送方确认最大的好处是它们是异步的。
		
	创建消费者
		1、连接到RabbitMQ；
		2、获得信道；
		3、声明交换器；
		4、声明队列；
		5、把队列和交换器绑定起来；
		6、消费消息；
		7、关闭信道；
		8、关闭连接；

集群架构
		
RabbitMQ内建集群目标
	1、允许消费者和生产者在Rabbit节点崩溃的情况下继续运行；
	2、通过添加更多的节点来线性扩展消息吞吐量；
	
RabbitMQ会始终记录以下四种类型的内部元数据
	1、队列元数据：队列名称和它们的属性（是否可持久化，是否自动删除）；
	2、交换器元数据：交换器名称、类型和属性（可持久化等）；
	3、绑定元数据：一张简单的表格扩展了如何将消息路由到队列；
	4、vhost元数据：为vhost内的队列、交换器和绑定提供命名空间和安全属性；
	
在单一节点内，RabbitMQ会将所有这些信息存储在内存中，同时将那些标记为可持久化的队列和交换器（以及它们的绑定）
	存储到硬盘上

在集群环境下
	1、将元数据存储到磁盘上（独立节点的默认设置）；
	2、仅存储在RAM中；
	
在集群中创建队列的话，集群只会在单个节点而不是在所有节点上创建完整的队列信息（元数据、状态、内容）；
	结果只有队列的所有者节点知道有关队列的所有信息，所有其他非所有者节点只知道队列的元数据和指向该队列
	存在的那个节点的指针；因此，当集群节点崩溃时，该节点的队列和关联的绑定就都消失了。附加在那些队列上
	的消费者丢失了其订阅信息，并且任何匹配该队列绑定信息的新消息也都丢失了；
	你可以让消费者重连到集群并重新创建队列，这种做法仅当队列最开始没有被设置成可持久化时才是可行的。
	如果重新创建的队列被标记成持久化了，那么在其他节点上重新声明它们的话会得到一个难看的404 NOT FOUND错误，
	这样确保了当失败节点恢复后加入集群，该节点上的队列消息不会丢失；想要该指定队列重回集群的唯一方法是恢复
	故障节点。但是，如果消费者尝试重建的队列不是可持久化的，那么重新声明就会成功，你可以准备重新绑定它们并
	传输数据；
	
为什么RabbitMQ不将队列内容和状态复制到所有节点上内：
	1、存储空间；
	2、性能；

交换绑定信息存储在集群的每个节点上；

当消息已经发布到信道上，但在路由完成之前节点发生故障的话
	生产者push命令不会返回消息的状态，这意味着你将承受丢失消息的风险；
	解决方案：
		1、AMQP事务；
		2、发送方确认；
		
RabbitMQ节点
	1、内存节点：将所有的队列、交换器、绑定、用户、权限和vhost元数据定义都仅存储在内存中；
	2、磁盘节点：将上述信息存储在硬盘上；
	
RabbitMQ要求在集群中至少有一个硬盘节点；如果硬盘节点崩溃，集群仍然可以保持运行，但无法更改任何东西；

集群的优缺点
	节点挂掉的话
	1、如果是非持久化队列，那么节点中队列里的消息会丢失；但生产者和消费者可以在其他节点重新创建队列，继续运行；
	2、如果队列是持久化的，那么节点中队列里的消息还在故障节点的磁盘上，但生产者和消费者不可以在其他节点重新创建队列，
		新发送的消息也会消失；

镜像队列
	镜像节点在集群的其他节点上有从队列拷贝，一旦队列主节点不可用，最老的从队列将被选举为新的主队列；
	
	中间添加从队列节点，新的节点只会包含那些在其添加进来之后从镜像队列发来的消息；
	
	发送方确认：会收到主节点、从节点两个确认消息；
		如果消息路由到从节点前，主节点宕机了，从节点被选举为主节点，那么发送方确认消息将永远不会到达；
	
	镜像队列丢失一个从节点的话，消费者不会注意到这一点；
	但如果主节点宕机的话，消费者需要重新附加并监听新的队列主拷贝；对于通过故障节点进行连接的消费者来说，
		这没什么困难，因为它们丢失了到节点的TCP连接，在它们重新附加到集群中一个新的节点时，会自动选取新的
		队列主拷贝；但对于那些通其他过节点附加到镜像队列且其他节点正常运行的消费者来说，RabbitMQ会发送给这些消费者
		一个消费者取消通知，告知它们已不再附加在队列主拷贝了；如果AMQP客户端库支持消费者取消通知的含义，
		那么它会抛出一个异常，同时应用程序就会知道已经不再附加到队列上了，需要重新附加；
		
		通过节点附加到镜像队列：集群中包含node0、node1，客户端可以TCP连接node0，而消费node1上的队列，
			因为整个集群都包含了路由表，这就是通过node0附加到node1上的队列；
		
6、从故障中恢复；
	通过负载均衡器(LVS、HAProxy等)处理重连并从故障中恢复：重新连接，并创建新的队列和交换器(如果可以的话)，
		保持系统持续可用；
	
7、warren
	如果应用程序无法承担丢失消息的风险，或者在故障队列恢复前无法处理不断重发消息的延迟，那么你需要我们提到的warren模式，
		即主备模式服务器，并前置一台负载均衡器来处理故障转移；主服务器和备服务器之间没有协作，所以任何影响到主服务器的问题不会
		自动转移到备用服务器。备节点仅在主节点故障时启用；主备完全隔离，没有共享，所以，当主节点故障时，从节点无法拥有主节点
		队列里的内容；
	
	Shovel：把消息从一个城市的Rabbit服务器路由到另一个城市的Rabbit，远距离通信和复制；
	
8、持久化信息已进入队列就会被写到磁盘，非持久化信息在内存使用率达到预设值时会被刷新到磁盘上；	

9、命令控制
	./rabbitmq-server -detached：以后台模式启动rabbitmq，启动节点和节点上的rabbitmq应用；
	
	./rabbitmqctl stop：关闭当前节点，包括节点上的rabbitmq应用；
	./rabbitmqctl -n rabbit@[hostname] stop: 关闭远程节点；
	
	./rabbitmqctl stop_app: 停止rabbitmq应用；
	
	新建用户：rabbitmqctl add_user userName userPassword;
	删除用户：rabbitmqctl delete_user userName;
	查询用户：rabbitmqctl list_users;
	修改密码：rabbitmqctl change_password userName newPassword;
	
	用户只能针对整个vhost进行授权或拒绝访问；
	
	设置权限，配置、写、读vhost1的权限：rabbitmqctl  set_permissions -p vhostName  user_admin '.*' '.*' '.*';
	
	新建virtual_host: rabbitmqctl add_vhost myHostName
	
    撤销virtual_host:rabbitmqctl  delete_vhost myHostName
	
	清除队列；
	rabbitmqctl stop_app;
	rabbitmqctl reset;
	rabbitmqctl start_app;
	然后重新创建用户；
	
10、异常消息没有ACK的话，队列中会堆积这些可以读到但没有确认的消息，直至队列被堵塞，所以异常中也要处理确认操作；
		rabbitmqctl  list_queues -p xxx.host name messages_ready messages_unacknowledged 

10、代码
	//生产者
	Connection conn = factory.newConnection();
	Channel channel = conn.createChannel(); //不是线程安全的
	
	channel.exchangeDeclare(exchangeName, "direct", true);  //声明交换器，direct类型可以使用默认的空字符串标识的交换器；
	channel.queueDeclare(queueName, true, false, false, null); //声明队列
	channel.queueBind(queueName, exchangeName, routingKey);
	
	channel.basicPublish(exchangeName, routingKey,
             new AMQP.BasicProperties.Builder()
               .headers(headers)
               .build()),
               messageBodyBytes);
	
	//消费者
	boolean autoAck = false;
	channel.basicConsume(queueName, autoAck, "myConsumerTag",
     new DefaultConsumer(channel) {
         @Override
         public void handleDelivery(String consumerTag,
                                    Envelope envelope,
                                    AMQP.BasicProperties properties,
                                    byte[] body)
             throws IOException
         {
             String routingKey = envelope.getRoutingKey();
             String contentType = properties.getContentType();
             long deliveryTag = envelope.getDeliveryTag();
             // (process the message components here ...)
             channel.basicAck(deliveryTag, false);
         }
     });


































