
***********************************************************************

zookeeper

CAP：一致性、可用性、分区容错性；

	一致性：数据在多个副本之间保持一致；
	可用性：对于用户的每一个操作请求总是能够在有限的时间内返回结果；
	分区容错性；分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足
		一致性和可用性的服务，除非是整个网络环境都发生了故障；
	
	放弃P：为了解决分区容错性，可以把数据放到一台主机上，分区容错性就消失了；
	放弃A：当出现分区容错时，就等待一段时间，到数据一致性完成；
	放弃C：放弃一致性是指放弃强一致性，主张最终一致性；
	
BASE：基本可用、弱状态/中间状态、最终一致性；

2PC：两阶段提交
	绝大部分关系型数据库都采用二阶段提交协议来完成分布式事务处理的；
	
	优点：原理简单、实现方便；
	缺点：同步阻塞、单点故障、脑裂；
		同步阻塞：所有参与该事务操作的逻辑都处于阻塞状态，各个参与者在等待其他参与者响应的过程中，都无法进行其他任何操作；
		单点故障：协调者单点；
		数据不一致：在二阶段提交协议的阶段二，即执行事务提交的时候，当协调者向所有的参与者发送commit请求之后，发生了局部
			网络异常或者是协调者在尚未发送完commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了commit请求，于是，这部分
			收到了commit请求的参与者就会进行事务的提交，而其他没有收到commit请求的参与者则无法进行事务提交，于是整个分布式系统
			便出现了数据不一致性现象；
		太过保守：如果在协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者无法获取到所有参与者的响应信息的话，
			这时协调者只能依靠其自身的超时机制来判断是否需要中断事务，这样的策略显的比较保守。换句话说，二阶段提交协议没有设计
			较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败；
	
	阶段一：提交事务请求，投票阶段；
		1、事务询问
			协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应；
			
		2、执行事务
			各参与者节点执行事务操作，并将Undo和Redo信息记入事务日志中；
			
		3、各参与者向协调者反馈事务询问的响应；
			如果参与者成功执行了事务操作，那么就反馈给协调者YES响应，表示事务可以执行；如果参与者没有成功执行事务，
			那么就反馈给协调者NO响应，表示事务不可以执行；
	
	阶段二：执行事务提交；
		
		假如全是YES响应，那么执行事务提交：
			1、发送提交请求；
				协调者向所有参与者发送commit请求；
			
			2、事务提交；
				参与者收到commit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源；
			
			3、反馈事务提交结果；
				参与者在完成事务提交后，向协调者发送Ack消息；
			
			4、完成事务；
				协调者接收到所有参与者反馈的Ack消息后，完成事务；
				
		中断事务，假如任何一个参与者向协调者反馈了NO响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应那么就会中断事务；
			1、发送回滚请求；
				协调者向所有参与者节点发出Rollback请求；
			
			2、事务回滚；
				参与者接收到Rollback请求后，会利用其在阶段一中记录的Undo信息来执行事务回滚操作，并在完成回滚之后
				释放在整个事务执行期间占用的资源；
				
			3、反馈事务回滚结果；
				参与者在完成事务回滚之后，向协调者发送Ack信息；
				
			4、中断事务；
				协调者在接收到所有参与者反馈的Ack消息后，完成事务中断；
			
		
3PC，三阶段提交
	将二阶段提交中的“提交事务请求”过程一分为二，形成了由CanCommit、PreCommit、doCommit三个阶段组成的事务处理协议；
		
	阶段一：CanCommit；
		1、事务询问：
			协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应；
			
		2、各参与者向协调者反馈事务询问的响应；
			参与者在接收到来自协调者的canCommit请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈YES响应，
			并进入预备状态，否则反馈NO响应。
		
	第二阶段：PreCommit：
		在阶段二中，协调者会根据各参与者的反馈情况来决定是否可以进行事务的PreCommit操作，正常请况下，包含两种可能：
			执行事务预提交
				假如协调者从所有的参与者获得的反馈都是YES响应，那么就会执行事务预提交；
				1、发送预提交请求；
					协调者向所有参与者节点发出preCommit的请求，并进入Prepared阶段；
				
				2、事务预提交；
					参与者接收到preCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。
				
				3、各参与者向协调者反馈事务执行的响应；
					如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令：提交/commit或终止/abort;
					
			中断事务
				加入任何一个参与者向协调者反馈了NO响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。
				1、发送中断请求；
					协调者向所有参与者节点发出abort请求；
				
				2、中断事务；
					无论是收到来自协调者的abort请求，或者是在等待协调者请求过程中出现超时，参与者都会中断事务；
					
	阶段三：doCommiit
		该阶段将进行真正的事务提交，会存在以下两种可能的情况。
			执行提交
				1、发送提交请求；
					进入这一阶段，假设协调者处于正常工作状态，并且它接收到了来自所有参与者的Ack响应，那么它将从“预提交”
					状态转换到“提交”状态，并向所有的参与者发送doCommit请求；
				
				2、事务提交
					参与者接收到doCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源；
					
				3、反馈事务提交结果；
					参与者在完成事务提交之后，向协调者发送Ack消息；
					
				4、完成事务；
					协调者接收到所有参与者反馈的Ack消息后，完成事务；
				
			中断事务
				进入这一阶段，假设协调者处于正常工作状态，并且有任意一个参与者向协调者反馈了NO响应，或者在等待超时之后，
				协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务；
				1、发送中断请求；
					协调者向所有的参与者节点发送abort请求；
				
				2、事务回滚；
					参与者接收到abort请求后，会利用其在二阶段中记录的undo信息来执行事务回滚操作，并在完成回滚之后释放在
					整个事务执行期间占用的资源；
					
				3、反馈事务回滚结果；
					参与者在完成事务回滚之后，向协调者发送Ack消息；
					
				4、中断事务；
					协调者接收到所有参与者反馈的Ack消息后，中断事务；
					
				需要注意的是，一旦进入阶段三，可能会存在以下两种故障：
					1、协调者出现问题；
					2、协调者和参与者之间的网络出现故障；
					
				无论出现哪种情况，最终都会导致参与者无法及时接收到来自协调者的doCommit或是abort请求，针对这样的异常情况，
				参与者都会在等待超时之后，继续进行事务提交；
				
	优点：降低了参与者的阻塞范围，并且能在出现单点故障后继续达成一致；
	缺点：在参与者接收到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，
	在这种情况下，该参与者依然会进行事务的提交，这必然出现数据的不一致性；
	
Paxos算法
	是目前公认的解决分布式一致性问题最有效的算法之一；
	
	Proposer ：提议者
	Acceptor：决策者
	Client：产生议题者
	Learner：最终决策学习者
	
	在这些被提出的提案中，只有一个会被选中；
	
	P1：一个Acceptor必须批准它收到的第一个提案；
		解决：即使只有一个提案被提出的情况下，仍然可以选中一个提案；
	
	一个提案被选定需要由半数以上的Acceptor批准，即一个Acceptor必须能够批准不止一个提案；
		允许多个提案被选定，但所有被选定的提案都必须具有相同的value；
	
	P2：如果编号为Mn、Value值为V0的提案[Mn, V0]被选定了，那么所有比编号M0更高的，且被选定的提案，其Value值必须也是V0.
	
	P2a：如果编号为M0，Value值为V0的提案（即[M0, V0]）被选定了，那么所有比编号M0更高的，且被Acceptor批准的提案，其Value值必须也是V0。
	
	P2b：如果一个提案[M0, V0]被选定后，那么之后任何Proposer产生的编号更高的提案，其Value值都为V0。
		解决：如果一个提案已经被选定，但Proposer发送因为网络延迟，刚到达未参与选定提案的Acceptor；
		
	Proposer在产生一个M0提案时，必须知道当前某一个将要或已经被半数以上的Acceptor批准的编号小于Mn但为最大编号的提案；
		并且Proposer会要求所有的Acceptor都不要再批准任何编号小于Mn的提案。
		
		1、Proposer选择一个提案编号Mn，然后向某个Acceptor集合的成员发送请求，要求该集合中的Acceptor做出如下响应。
			a：向Proposer承诺，保证不再批准任何编号小于Mn的提案；
			b：如果Acceptor已经批准过任何提案，那么其就向Proposer反馈当前该Acceptor已经批准的编号小于Mn但为最大编号的那个提案的值；
			
		2、如果Proposer收到了来自半数以上的Acceptor的响应结果，那么它就可以产生编号为Mn、Value值为Vn的提案，这里的Vn是所有响应中
			编号最大的提案的Value值。当然还存在另一种情况，就是半数以上的Acceptor都没有批准过任何提案，即响应中不包含任何的提案，
			那么此时Vn值就可以由Proposer任意选择；
	
	在确定提案之后，Proposer就会将该提案再次发送给某个Acceptor集合，并期望获得它们的批准，我们称此请求为Accept请求。需要注意的一点
		是，此时接受Accept请求的Acceptor集合不一定是之前响应Prepare请求的Acceptor集合；
	
	阶段一：Prepare请求；
		1、Proposer选择一个提案编号M(n)，然后向Acceptor的某个超过半数的子集成员发送编号为M(n)的Prepare请求；
			Prepare可以在任何时候丢弃一个提案，哪怕针对该提案的请求和响应在提案被丢弃后会到达，但根据Paxos算法
			的一系列规约，依然可以保证其在提案选定上的正确性；
		
		2、如果一个Acceptor收到一个编号为M(n)的Prepare请求，且编号M(n)大于该Acceptor已经响应的所有Prepare请求的编号，那么
			它就会将它已经批准过的最大编号的提案作为响应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于M(n)的提案；
			如果编号M(n)小于该Acceptor已经响应的所有Prepare请求的编号，则可以直接抛弃；
		
	阶段二：Accept请求；
		1、如果Proposer收到来自半数以上的Acceptor对于其发出的编号为M(n)的Prepare请求的响应，那么它就会发送一个针对[M(n), V(n)]
			提案的Accept请求给Acceptor，注意，V(n)的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值；
			
		2、如果Acceptor收到这个针对[M(n), V(n)]提案的Accept请求，只要该Acceptor尚未对编号大于M(n)的Prepare请求做出响应，它就可以批准这个提案；
		
		
		
	1、Proposer向超过半数的Accept子集发送带序列号的申请，即prepare请求；
	
	2、Accept必须批准第一个申请Mn；
	
	3、Accept对小于Mn的申请直接抛弃，大于Mn的申请返回Mn的值Vn；
	
	4、如果Proposer收到来自半数以上的Acceptor对于Mn的响应，则发出Accept请求，包含Mn、Vn；
	
	5、如果Acceptor尚未响应过大于Mn的prepare请求，Acceptor就会通过这个提案；
	
	6、如果Proposer收到半数以上的Acceptor都通过了这个提案，那么Proposer就确定Mn/Vn被选中了；
	
	7、如果Proposer没收到半数以上，
		7.1、如果返回多个V，且有一个Vn由多于一半的Acceptor返回，那么Proposer就确认Vn被选中；
		7.2、如果返回多个V，且没有一个V由多于一半的Acceptor返回，那么Proposer就会把收到的最新的Mm/Vm的Accept请求发送出去（即顶最新的V），重复步骤6/7，直到Vm被选中；
	
	8、在accept请求阶段，如果发生异常等其他情况，需从步骤1从头开始；
	
	P1:一个acceptor必须批准(accept)第一次收到的提案;
	P2a:一旦一个具有value v的提案被选中(chosen)，那么之后任何acceptor 再次批准(accept)的提案必须具有value v;
	P2b:一旦一个具有value v的提案被选中(chosen)，那么以后任何 proposer 提出的提案必须具有value v;
	P2c:如果一个编号为n的提案具有value v，那么存在一个多数派，要么他们中所有人都没有批准(accept)编号小于n的任何提案，
		要么他们已经选中(accpet)的所有编号小于n的提案中编号最大的那个提案具有value v;

算法优化
1、Acceptor批准一个提案就发送给Learner，已通知哪些提案被选中了（其实不要这步骤也会最终选中一个提案的），交互次数要Acceptor * Learner，优化1，可以选出一个主Learner，Acceptor把信息传给主Learner，主Learner再扩散给从Learner，交互次数只需Acceptor + Learner，但存在Learner单点，所以主Learner应该是一个有限的集合；
2、Prepare1、Prepare2在prepare阶段一第一地递增发送，则会陷入死循环，所以一般只需要一个主Preparor进行提案即可，其他Preparor做备用即可；

角色：Proposer、Acceptor；

阶段：Prepare、Accept；

法定集合：大于一半的集合；
序列号：全局唯一递增序列号；

	初始val为null；
	初始no为null；
	初始new_no为全局唯一序列编号；
1、提议者向超过一半的决策者发送prepareRequest(new_no)，包含一个全局唯一递增的序列号new_no；
2、决策者收到prepareRequest请求后，取出自己保存的(no, val)，如果no>new_no, 则丢弃prepareRequest（要通知提议者），否则替换no为new_no，返回(new_no, val);
3、如果提议者获超过一半的决策者的响应，则从中取出最大序列号对应的new_val，如果new_val为空，则自己随便生成一个；如果没有获得超过一半的决策者响应，则直接跳回步骤1；
4、提议者向超过一半的决策者发起acceptRequest(new_no, new_val)；
5、决策者收到acceptRequest(new_no, new_val)，若new_no>=no，则批准此请求，并替换val为new_val，丢弃acceptRequest（要通知提议者）；
6、提议者如果收到超过一半的批准响应，则确认请求已被批准，否则，跳步骤1；


微信自研生产级 Paxos 类库 PhxPaxos 实现原理介绍
http://www.tuicool.com/articles/fMR3m2r
http://mp.weixin.qq.com/s?__biz=MzI4NDMyNTU2Mw==&mid=2247483695&idx=1&sn=91ea422913fc62579e020e941d1d059e&scene=0&utm_source=tuicool&utm_medium=referral

		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
