
哈夫曼编码、二叉树遍历、图、最小生成树、最短路径、拓扑排序、关键路径
	排序：冒泡排序、选择排序、归并排序、快速排序；
	查找：顺序查找、折半查找（针对有序）；
	
***********************************************************************

1、数据结构：线性表(数组/链表)、栈与队列、串、树、图;

   时间复杂度O(1)、O(n)、O(n2)、...
   
2、哈夫曼编码：取最小的两个节点，左小右大，组成一棵树，如此循环；
   这样出现频率最低的，被扫描到的概率也最低，或者频率最高的，编码长度最短；
	
3、树的数据结构：二叉树、前序遍历、中序遍历、后序遍历、哈夫曼树；

	前序遍历
		void pre_order(TreeNode* Node){
			if(Node != NULL){
				printf("%d ",Node->data);
				pre_order(Node->left);
				pre_order(Node->right);
			}
		}

4、图

	图的数据结构：1、邻接矩阵(二维数组)；2、邻接表(从顶点出发，链表出相邻的节点)；3、十字链表(有out/in指针)；4、邻接多重表；5、边集数组；
		深度优先遍历、广度优先遍历；
	
	最小生成树：各个城市铺电缆，用最短的电缆连接所有的城市;
		1、克鲁斯卡尔算法
			将图中边按其权值由小到大的次序顺序选取,若选边后不形成回路,则保留作为一条边,
				若形成回路则除去.依次选够(n-1)条边,即得最小生成树.(n为顶点数);
		
		2、普里姆算法
			随意取一个点，取关联点的最小的边，如此循环；
			
	最短路径：坐地铁从A地到B地，怎么选最短路径；
		1、迪杰斯特拉算法：单个源点到所有顶点的最短路径；
			 求A点到Z点的距离；
			1)列出A点到所有点的距离，求出最短距离D(A,E);
			2)列出A点到所有点X的距离（不包含E点），求出次短距离D(A,G)；
			  次短离或者是D(A,X)，或者是D(A,E)+D(E,X)，二者选短者；
			3)列出A点到所有点X的距离（不包含E、G点），求出次短距离D(A,W)；
			  次短离或者是D(A,W)，或者是D(A,G)+D(G,X)，G点即上次求出的次短距离，二者选短者；
			4)如此循环，即可得出A点到所有点的最端距离；
			
		2、弗洛伊德算法：任一顶点到其余所有顶点的最短路径；
			 1)让所有边上加入中间顶点1，取A[i][j]与A[i][1]+A[1][j]中较小的值作A[i][j]的值，完成后得到A(1)矩阵;
			 2)让所有边上加入中间顶点2，取A[i][j]与A[i][2]+A[2][j]中较小的值，完成后得到A(2)…，其中，A[i][2]取A(1)矩阵得出的值！
				如此进行下去，当第n步完成后，得到A(n)，A(n)即为我们所求结果,A(n)[i][j]表示顶点i到顶点j的最短距离。
	
	拓扑排序
		从图中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出
			全部顶点或图中不存在入度为0的顶点为止。如果没输出全部顶点，说明存在回路；拓扑排序保证施工的步骤是顺序执行；
	
	关键路径(基于拓扑排序)（https://blog.csdn.net/fu_jian_ping/article/details/88962697）
		1、拓扑排序，并求出最早发生时间 VE；
		2、逆拓扑排序，并求出最晚发生时间 VL；
		3、求关键路径：每条弧s的最早开始时间e(s) = 最迟开始时间l(s);
		
		事件的最早发生时间
			拓扑排序，ve[0] = 0;
			ve[k] = max(ve[j] + len(vj, vk));

		事件的最迟发生时间
			逆拓扑排序，vl[n] = ve[n]
			vl[j] = min(vl[k] - len(vj, vk), ...);

		活动的最早发生时间 = ve[j]
			ai = <vj, vk>

		活动的最迟发生时间 = vl[k] - len(vj, vk)
			ai = <vj, vk>

		关键路径 = （活动的最迟发生时间 = 活动的最早发生时间）
		
5、排序：冒泡排序、简单选择排序、插入排序、希尔排序、归并排序、快速排序；
	选择排序：冒泡排序的优化，只改变下标，少移动数据节点；
	插入排序：将一个数插入到一个已经排好序的数列中
	希尔排序：跳跃分组排序；//增量
	归并排序：针对有序数列；
	
	快速排序：
		public int getMiddle(int[] list, int low, int high) {
			int tmp = list[low]; //数组的第一个作为中轴
			while (low < high) {
				while (low < high && list[high] >= tmp) {
					high--;
				}
				
				list[low] = list[high]; //比中轴小的记录移到低端
				
				while (low < high && list[low] <= tmp) {
					low++;
				}
				
				list[high] = list[low]; //比中轴大的记录移到高端
			}
			
			list[low] = tmp; //中轴记录到尾
			
			return low; //返回中轴的位置
		}
		
		public void _quickSort(int[] list, int low, int high) {
			if (low < high){
				int middle = getMiddle(list, low, high); //将list数组进行一分为二  
				_quickSort(list, low, middle-1); //对低字表进行递归排序  
				_quickSort(list, middle+1, high); //对高字表进行递归排序  
			}
		}
		
6、查找：顺序查找、有序表查找(折半查找、插值查找、斐波那契查找)；
	
	
*******************************************************************************

