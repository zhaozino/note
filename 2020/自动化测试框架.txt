
指导思想
	简单：构造数据简单，接口图形化拖拽，服务图形化拖拽；通过测试环境流量录制，摄取测试案例，以减少人工编辑的人力；
	高效：dsl；
	可重复：测试案例编写、数据的隔离、环境的隔离、Mock、DockerFile；
	生产流量：录制、回放；

	避免从开发的复杂度转变为测试的复杂度，比如测试案例太难维护；测试环境太难维护；

开发插件化
	跨语言
	mysql拦截器插件
	redis拦截器
	kafka拦截器
	
功能点
	1、代码覆盖率统计；
	2、yaml实现；
	3、yaml的web编辑；
	4、比较器的插件化实现；
	5、生产流量录制、回放；
	6、开发/测试流量的录制，自动生成测试案例；
	7、MockServer（http、kafka、redis、mySql）；
	8、数据的隔离（ddl、dml）；
	9、环境的隔离（DockerFile）；
	
架构图

	LVS ——> API Gateway ——> MicroService ——> kafkaProxy/redisProxy/MyCat ——> kafka/redis/mysql ——> 

*****************************************************************************************************

自动化测试框架一个非常重要的思想是，案例要可以重复执行！

自动化测试框架设计的一个重要原则是插件化；
	参考springBootFactories、dubboSPI等；
	涉及到跨语言的插件，可以尝试restful协议交互；
	
Mock的实现：
	1、一个是通过java探针来实现；非侵入；
	2、一个通过自动化测试框架整合中间件来实现；推荐；
		httpService可以通过OpenResty/Lua来实现；
		mysql拦截器插件
		redis拦截器
		kafka拦截器
	
yml转为web，可视化，可编辑；

yml继承关系；

yml要支持生产的录制和回放，用来回归测试；

properties定义；

httpService/rpcService等定义；

mysql/redis等定义；

接口定义；

程序里有会有噪音，比如uuid，mysql的主键autoIncrement，这些噪音具有不可重复性，需要排除；

约定保留的mysql表，从业务数据库读取，主要用来标记元数据表，且是只读；写的风险由用户承担；
	一般只对数据稳定的不经常变化的表做为元数据表，因为数据一旦改变，就会影响到案例的执行结果，导致案例不能重复执行；

每个案例一条记录的案例标识/每个案例一个临时表的前缀/每个案例一个临时库；
	每个案例之间是解耦的，互不影响；
	
接口之间可以定义先后顺序，可以依赖返回的结果；

mysql初始化数据；主要为了造一些场景，使案例可重复执行；

通过swagger注解来提取入参、出参的数据结构，可以减少人工编辑的人力；

案例、接口、httpService等也要有抽象概念和继承关系；

案例编号要唯一，因为要和mysql表中的数据关联；

出参/入参校验可以分多钟规则
	完全匹配，特定字段匹配，特定字段不匹配等；
	非空、大小等于、范围等；

httpService、sql等要加上顺序编号，因为相同httpService带相同的参数，可能重复执行多次，但可能每次返回的数据是不一样的；

httpService的参数也包括header等隐性的属性；

在发生错误时，要记录程序上下文的参数数据；

案例的代码覆盖率统计；

通过分析语法自动生成案例模板；

autoTest可以整合到CI里；

要扩展成类似postMan的功能，用来记录测试案例，人眼判断，也是一种校验器；

yml要支持定义变量；

自动化测试框架要支持python等脚本语言调用；

案例1
	接口1：并行、串行、依赖
		入参：
		
		httpService1
			入参：用来校验参数；
			出参：Mock出来的结果；
		...
		httpServiceN
			入参：
			出参：
		
		mysql结果表/中间表数据验证：
			sql1：
			sql1结果；
			...
			sqlN：
			sqlN结果：
		
		出参：
	接口2
	...
	接口N

通过DockerFile把测试环境的状态记录下来

将需求转换成半结构化的自然语言，自然语言再转换成结构化的测试脚本，测试脚本再自动化执行；

*****************************************************************************************************************
测试中台：通过服务化来完成测试环境、测试数据的构建，而不是人工来做这些脏话累活；
代码染色：通过比较改动的代码，计算出影响到的接口，回归测试时，重点测试这些接口；
键盘、鼠标的录制和回放：减少UI测试的人力投入，只需像看电影一样检查UI交互、结果数据就行；甚至对某些测试场景，只需检查结果页面即可，不需全程盯着，
	这样可以在一台电脑上虚拟出多个虚拟机，就可以在一台电脑上同时跑多个案例，最后人工介入比较结果页即可；再进一步，直接由人工智能来识别全程页面的变化，
	和录制的页面自动对比；
接口测试：

