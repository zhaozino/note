编译器和处理器必须同时遵守重排规则。多核处理器需使用内存屏障指令来确保一致性。即使编译器优化掉了一个字段访问（因为一个读入的值未被使用），需要产生内存屏障，就像这个访问仍然需要保护。（可参考下面的优化掉内存屏障的章节）。

内存屏障指令仅直接控制CPU与其缓存之间，与垃圾回收机制中“写屏障（write barriers）”无关。

编译器或者CPU的代码的结构重排排序，达到最佳效果。

写内存屏障（Store Memory Barrier）：处理器将存储缓存值写回主存（阻塞方式）。

读内存屏障（Load Memory Barrier）：处理器将读主内存，处理失效队列（阻塞方式）。

保证两个操作之间数据的可见性。

volatile读前插读屏障，写后加写屏障，避免CPU重排导致的问题，实现多线程之间数据的可见性。读前/写后；

StoreLoad开销最大。万能屏障，兼具其它三种内存屏障功能。执行时，处理器通常要把写缓冲区中的数据全部刷新的内存中

对于处理器来说，内存屏障会导致cpu缓存的刷新，刷新时，会遵循缓存一致性协议。

lock：解锁时，jvm会强制刷新cpu缓存，导致当前线程更改，对其他线程可见。

volatile：标记volatile的字段，在写操作时，会强制刷新cpu缓存，标记volatile的字段，每次读取都是直接读内存。

final：即时编译器在final写操作后，会插入内存屏障，来禁止重排序，保证可见性

