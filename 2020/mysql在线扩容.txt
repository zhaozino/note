mycat，原来有2台master mysql（还有2台salve），现在要扩容到4台master；
假设分库键key按hash分库，原来老路由规则：key%2 == 0，路由到mysql0，key%2 == 1路由到mysql1；
现在新路由规则：key%4 == 0，路由到mysql0，key%4 == 1路由到mysql1，key%4 == 2路由到mysql2，key%4 == 3路由到mysql3；
1、将新的两台mysql主机挂载到原来2台master下，作为salve进行全量复制，mysql2挂载到mysql0下，mysql3挂载到mysql1下；
2、等到接近复制完成（假设原来库一直在写入，因此无法做到完全复制），在mycat中block住key%4==2、key%4==3路由的写入（即阻塞应该路由到新库的写入）；
3、保证新mysql2、mysql3复制到了block的时间点后，停止复制，使其变为可写数据库；
4、修改mycat到新的路由规则，停止block，使key%4==2、key%4==3分别写到新的库mysql2、mysql3中；
5、对mysql中不符合新路由规则的旧数据进行清理；



如果是同一台mysql中的一张表table，要分成两张表table1、table2；
1、新建增量表t3：包含主键、table主键、更新时间3个列即可；
3、在table上新建触发器，对所有的insert、update、delete时，把主键写入增量表t3；
4、对原始表的数据读取，按规则写入table1、table2，记录迁移时间；这个步骤，也可以对原始表做一个备份后读取，记录迁移时间；这个过程需要保证记录增量的操作已经在进行。
5、待全量迁移完毕后，删除增量表中开始时间之前的数据。开始读取后面有变化的主键，读取到结果的根据规则写入新表，读取不到（原表中已经delete）删除新表中的相应的数据，一直进行着，增量表中，
  迁移过程注意日志保存和相应的清理；
6、待增量追评或是增量表中只有少量的数据的情况，同时确保是业务低峰情况下，对迁移表下发block写入动作，更新规则，推送给DBProxy，原始对该表的连接全部干掉。同时确认增量表已经迁移完毕。
7、应用新规则，放开写入动作，新的流量下发到新表中。

先说说聚簇索引，聚簇索引有两个明显特征：
1、索引必须为唯一索引
2、叶子节点处储存的是整行数据（这也是为何用主键（聚簇索引）进行查询时，查询速度会较快的原因（减少回表查询））

非聚簇索引有两个明显特征：
1、索引值必须为可不唯一
2、叶子节点处储存的索引行跟主键（key+pk cols）

这也是为何在新建数据表时，会推荐建立自增 id 作为主键，同时 id 自增确保业务层面上的无意义。== 确保主键 ID 业务上无意义很重要，因为它确保你再已生成记录的主键 ID，是不会被 update 的 ==。如果是随机主键或者频繁更新主键的话，就会存在数据页频繁断裂，B + 树不饱和的情况（原因：聚簇索引是按顺序进行排序的）。而如果设置主键是自增，那么每一次都是在聚集索引的最后增加，当一页写满，就会自动开辟一个新页，不会有聚集索引树分裂这一步，效率会比随机主键高很多。这也是很多建表规范要求主键自增的原因。

有人会疑虑似乎聚簇索引一定会是主键，那如果数据表不建立主键的话是否就没有聚簇索引了？
在 InnoDB 中，聚集索引不一定是主键，但是主键一定是聚集索引：原因是如果没有定义主键，聚集索引可能是第一个不允许为 null 的唯一索引，如果也没有这样的唯一索引，InnoDB 会选择内置 6 字节长的 ROWID 作为隐含的聚集索引。
InnoDB 的数据是按照主键顺序存放的，而聚集索引就是按照每张表的主键构造一颗 B+ 树，它的叶子节点存放的是整行数据。
每张 InnoDB 表都有一个聚集索引，但是不一定有主键。

使用非聚簇索引查询数据时，一定要回表查询吗？
回表查询是由于非聚簇索引的 B+Tree 叶子节点只记录了，PK cols 与 key。这就造成当查询字段非主键跟索引字段时，索引树无法直接提供所有数据列，从而要进行一次回表查询，也就是拿着主键 ID 再进行一次查询操作。
例如 t1 表

select * from t1 where c = 1; #sql_1
select id,c from t1 where c = 1; #sql_2

当查询被非聚簇索引涵盖列时，则不需要走回表操作。即 sql_2 不需要走回表查询，sql_1 需要。sql2因为查询的字段本身就是索引字段，包含在非聚簇索引中，所以不需要再回表；



一致性的非锁定读
在默认配置下innodb的隔离级别是repeatable read，innodb的select操作使用的是一致性非锁定读

一致性的非锁定行读（consistent nonlocking read，简称CNR）是指InnoDB存储引擎通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中运行的数据。如果读取的行正在执行delete、update操作，这时读取操作不会因此而会等待行上锁的释放，相反，InnoDB存储引擎会去读取行的一个快照数据。

之所以称为非锁定度，是因为不需要等待访问数据行上的X锁的释放。快照数据是指该行之前版本的数据，通过undo段来实现（undo用来在事务中回滚数据）。

在Read Committed和Repeatable Read模式下，innodb存储引擎使用默认的一致性非锁定读。在Read Committed隔离级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据；而在Repeatable Read隔离级别下，对于快照数据，一致性非锁定读总是读取事务开始时的行数据版本。

一致性锁定读
默认情况下，innodb存储引擎的select操作使用一致性非锁定读，但是在某些情况下，需要对读操作进行加锁以保证数据逻辑的一致性。Innodb存储引擎对select语句支持2种一致性锁定读(locking read)操作;

SELECT ... FOR UPDATE对于读取的行记录加一个X排它锁，其他事务不能对锁定的行加任何锁。

SELECT ... LOCK IN SHARE MODE对于读取的行记录添加一个S共享锁。其它事务可以向被锁定的行加S锁，但是不允许添加X锁，否则会被阻塞。



